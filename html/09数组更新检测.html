<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>数组更新检测</title>
<meta name="description" content="">
<meta name="keywords" content="">
<link href="" rel="stylesheet">
</head>
<body>

	
	<ul id="arr01">
		<li v-for="n in evenNumbers">{{ n }}</li>
		<li v-for="n in even()">{{ n }}</li>
	</ul>
	
    
</body>
<script type="text/javascript" src="../js/vue.js"></script>
<script>	

	/*
	变异方法：这些方法改变了原数组，触发视图更新，这些叫做变异方法
	push()
	pop()
	shift()
	unshift()
	splice()
	sort()
	reverse()
	 */ 
	


	// 非变异方法（重塑数组）：不会改变原数组，总是返回新数组，不触发视图更新，当使用非变异方法时，可以用新数组替换旧数组触发视图
	// filter(), concat(), slice()

	/* example1.items = example1.items.filter(function (item) {
	  return item.message.match(/Foo/)
	})
	*/

	/*
	由于 JavaScript 的限制， Vue 不能检测以下变动的数组：

		1、当你利用索引直接设置一个项时，例如： vm.items[indexOfItem] = newValue
		2、当你修改数组的长度时，例如： vm.items.length = newLength

	为了避免第一种情况，以下两种方式将达到像 vm.items[indexOfItem] = newValue 的效果， 同时也将触发状态更新：

	1). Vue.set
		Vue.set(example1.items, indexOfItem, newValue)
	2). Array.prototype.splice`
		example1.items.splice(indexOfItem, 1, newValue)

	避免第二种情况，使用 splice：
		example1.items.splice(newLength)
	 */ 
	


	var vm1 = new Vue({
		el: '#arr01',
		data: {
			numbers: [ 1, 2, 3, 4, 5 ],
		},
		computed: {//计算属性
			evenNumbers: function(){
				return this.numbers.filter(function(number){
					return number% 2 === 0;
				})
			}
		},
		methods: {
			even: function(){
				return this.numbers.filter(function(number){
					return number%2 === 0;
				})
			}
		}
	})


</script>
</html>